# -*- coding: utf-8 -*-
"""Image segmentation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17SubXOtY8m8jLgbVy-4kI1oA0Jg5AjPc

Binary Thresholding:

Pixels above the threshold are set to the maximum value (e.g., 255).

Pixels below the threshold are set to 0.

Inverse Binary Thresholding:

Opposite of binary thresholding: pixels above the threshold are set to 0, while pixels below or equal to it are set to the maximum value.

Truncated Thresholding:

Pixels above the threshold are set to the threshold value, but the rest remain unchanged.

Tozero Thresholding:

Pixels below the threshold are set to 0, and the remaining pixels retain their original values.

Tozero Inverted Thresholding:

Opposite of Tozero Thresholding: Pixels above the threshold are set to 0, and the rest retain their original values.

Otsu's Thresholding:

Automatically determines the optimal threshold value by minimizing intra-class variance.

Best for images with bimodal histograms (two distinct peaks).

Adaptive Thresholding:

Dynamically calculates the threshold for small regions of the image.

Types:

Mean: Takes the average of the neighborhood pixel values.

Gaussian: Computes a weighted average using a Gaussian window.

Multi-Level Thresholding:

Uses multiple thresholds to segment the image into more than two regions or classes.

Binary Thresholding
"""

import cv2
import numpy as np
from matplotlib import pyplot as plt

# Load the image
image_path = '/content/Screenshot 2024-04-26 101452.png'  # Replace with your image path
image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)

# Check if image is loaded
if image is None:
    print("Error: Image not found!")
    exit()

# Apply binary thresholding
threshold_value = 128  # You can experiment with this value
max_value = 255
_, binary_threshold = cv2.threshold(image, threshold_value, max_value, cv2.THRESH_BINARY)

# Display the results
titles = ['Original Image', 'Binary Threshold']
images = [image, binary_threshold]

for i in range(2):
    plt.subplot(1, 2, i+1)
    plt.imshow(images[i], cmap='gray')
    plt.title(titles[i])
    plt.xticks([]), plt.yticks([])

plt.show()

"""Otsu's Techniques"""

import cv2
import numpy as np
from matplotlib import pyplot as plt

# Load the image
image_path = '/content/Screenshot 2024-04-26 101452.png'  # Replace with your image path
image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)

# Check if image is loaded
if image is None:
    print("Error: Image not found!")
    exit()

# Apply Otsu's thresholding
_, otsu_threshold = cv2.threshold(image, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)

# Display the results
titles = ['Original Image', 'Otsu Threshold']
images = [image, otsu_threshold]

for i in range(2):
    plt.subplot(1, 2, i+1)
    plt.imshow(images[i], cmap='gray')
    plt.title(titles[i])
    plt.xticks([]), plt.yticks([])

plt.show()

# Print the computed threshold value
otsu_value = cv2.threshold(image, 0, 255, cv2.THRESH_OTSU)[1]
print(f"Otsu's computed threshold value: {otsu_value}")

import cv2
import numpy as np
from matplotlib import pyplot as plt

# Load the image
image_path = '/content/Screenshot 2024-04-26 101452.png'  # Replace with your image path
image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)

# Check if image is loaded
if image is None:
    print("Error: Image not found!")
    exit()

# Binary thresholding
threshold_value = 128
_, binary_threshold = cv2.threshold(image, threshold_value, 255, cv2.THRESH_BINARY)

# Otsu's thresholding
_, otsu_threshold = cv2.threshold(image, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)

# Plotting the outputs side-by-side
titles = ['Original Image', 'Binary Threshold', 'Otsu Threshold']
images = [image, binary_threshold, otsu_threshold]

for i in range(3):
    plt.subplot(1, 3, i+1)
    plt.imshow(images[i], cmap='gray')
    plt.title(titles[i])
    plt.xticks([]), plt.yticks([])

plt.show()

# Print the threshold values
print(f"Binary Threshold Value: {threshold_value}")
print(f"Otsu's Computed Threshold Value: {otsu_threshold.max()}")

import cv2
import numpy as np
from matplotlib import pyplot as plt

# Load the image
image_path = '/content/Screenshot 2024-04-26 101452.png'  # Replace with your image path
image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)

# Check if image is loaded
if image is None:
    print("Error: Image not found!")
    exit()

# Apply adaptive thresholding
adaptive_mean = cv2.adaptiveThreshold(image, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, 11, 2)
adaptive_gaussian = cv2.adaptiveThreshold(image, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 11, 2)

# Display the results
titles = ['Original Image', 'Adaptive Mean Thresholding', 'Adaptive Gaussian Thresholding']
images = [image, adaptive_mean, adaptive_gaussian]

for i in range(3):
    plt.subplot(1, 3, i+1)
    plt.imshow(images[i], cmap='gray')
    plt.title(titles[i])
    plt.xticks([]), plt.yticks([])

plt.show()

import cv2
import numpy as np
from matplotlib import pyplot as plt

# Load the image
image_path = '/content/Screenshot 2024-04-26 101452.png'  # Replace with your image path
image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)

# Check if image is loaded
if image is None:
    print("Error: Image not found!")
    exit()

# Apply Truncated Thresholding
threshold_value = 128
_, truncated_threshold = cv2.threshold(image, threshold_value, 255, cv2.THRESH_TRUNC)

# Apply Inverse Binary Thresholding
_, inverse_binary_threshold = cv2.threshold(image, threshold_value, 255, cv2.THRESH_BINARY_INV)

# Display the results
titles = ['Original Image', 'Truncated Threshold', 'Inverse Binary Threshold']
images = [image, truncated_threshold, inverse_binary_threshold]

for i in range(3):
    plt.subplot(1, 3, i+1)
    plt.imshow(images[i], cmap='gray')
    plt.title(titles[i])
    plt.xticks([]), plt.yticks([])

plt.show()